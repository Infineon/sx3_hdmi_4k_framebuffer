// ===========================================================================
// Verilog module generated by IPexpress
// Filename: test_mem_ctrl.v
// Copyright 2013 (c) Lattice Semiconductor Corporation. All rights reserved.
// ===========================================================================

`timescale 1 ps / 1 ps
`include "ddr3_sdram_mem_params_ddr3_ip_inst.v"
`include "tb_config_params.v"
module  test_mem_ctrl;

`define ddr3_ip_inst_READ 4'b0001
`define ddr3_ip_inst_WRITE 4'b0010
`define ddr3_ip_inst_READA 4'b0011
`define ddr3_ip_inst_WRITEA 4'b0100
`define ddr3_ip_inst_PDOWN_ENT 4'b0101
`define ddr3_ip_inst_LMR 4'b0110
`define ddr3_ip_inst_SEL_REF_ENT 4'b1000
`define ddr3_ip_inst_SEL_REF_EXIT 4'b1001
`define ddr3_ip_inst_PDOWN_EXIT 4'b1011
`define ddr3_ip_inst_ZQ_LNG 4'b1100
`define ddr3_ip_inst_ZQ_SHRT 4'b1101

parameter LOW = 1'b0;
parameter HIGH = 1'b1;

// ====================================================================
// Internal signals
// ====================================================================
wire   [15:0]                   ddr_dq;
wire   [1:0]                    ddr_dqs;
wire   [1:0]                    inv_ddr_dqs;
wire   [1:0]                    ddr_dqm;
wire   [1:0]                    ddr_dqm_temp;
wire   [1:0]                    ddr_dqs_d;

// ====================================================================
// Registers used by the tasks to drive the input signals of the
// FPGA bridge
// ====================================================================

reg                             rst_n;
reg    [3:0]                    cmd;
reg                             cmd_valid;
reg                             init_start;
reg                             mem_rst_n;
reg                             ofly_burst_len;
reg    [4:0]                    ff_burst_count;
reg    [7:0]                    dmsel;
reg    [26:0]                   addr;

reg    [2:0]                    ar_burst_cnt;
reg    [2:0]                    ar_burst_en;
reg    [3:0]                    db_size;
reg    [15:0]                   trefi;

reg    [63:0]                   write_data;
reg    [7:0]                    data_mask;
wire   [63:0]                   read_data;

// ====================================================================
// Output signals from the controller
// ====================================================================


wire                            cmd_rdy;
wire                            init_done;

wire   [0:0]                    ddr_cke;
wire                            ddr_ras_n;
wire                            ddr_cas_n;
wire                            ddr_we_n;
wire                            ddr_resetn;
wire   [0:0]                    ddr_cs_n;
wire   [0:0]                    ddr_odt;
wire   [13:0]                   ddr_ad;
wire   [2:0]                    ddr_ba;
wire                            data_rdy;

// ====================================================================
// Clock generation logic and Parameters
// ====================================================================
reg                             clk_in;     // memory controller clock
wire                            sys_clk;    // memory controller clock
reg                             mem_clk;    // memory controller clock
wire                            clk;
wire   [0:0]                    ddr_clk;    // clock connected to the memory
wire   [0:0]                    ddr_clk_n;  // clock connected to the memory
wire                            ddr_clk_d;
reg                             cs_addr;

`ifdef ddr3_ip_inst_GATE_SIM
genvar p;

generate
   for (p=0;p< 15+1;p=p+1)
   begin: p1
    pullup (ddr_dq[p]);
   end
endgenerate
`endif


GSR GSR_INST (.GSR(rst_n));
PUR PUR_INST (.PUR(1'b1));

//Simulation Clock Cycle in PS
//parameter c = HALF_CLOCK_PERIOD;
parameter c = `ddr3_ip_inst_REFCLK_PERIOD_BY2;  // PLL_FIN is refclk to PLL.  unit of c is ps.

initial begin
    clk_in         = 0;
    mem_clk        = 0;
    init_start     = 0;
    mem_rst_n      = 1'b1;
    addr           = 0;
    ff_burst_count = 1;
    cmd            = 0;
    dmsel          = 'b0;
    cmd_valid      = 0;
    write_data     = 0;     //  64'h0123456789ABCDEF
    data_mask      = 0;
    ofly_burst_len = 0;
    ar_burst_cnt   = 4;
    ar_burst_en    = 3'b000;
    trefi          = 16'b0000011000011000;
    cs_addr        = 1'b0;
end

always #(c)   clk_in   = ~clk_in;
always #(c/2) mem_clk  = ~mem_clk;

//assign clk = clk_in;
// ====================================================================
// This will provide display of the current settings, good for debugging
// ====================================================================

initial begin
   $display ("// ==================================================");
   $display ("INFO: Current Data Bus Width is %0d bits", 15+1);
   $display ("INFO: Current Addr Bus Width is %0d bits", 26+1);
   $display ("INFO: Current User Data Bus Width is %0d bits", 63+1);
   $display ("INFO: Current User Data Mask Bus Width is %0d bits", 7+1);
   $display ("INFO: Current Frequency is %0d MHz", (1000000/c));
   $display ("INFO: Current Clock Period is %2f ns", c/1000.0);
 `ifdef ddr3_ip_inst_GATE_SIM
   $display ("INFO: Doing Gate Level Simulation");
 `endif
   $display ("// ==================================================");
end

reg   dm_toggle;       // 0: data mask=0
                       // 1: random pattern on data mask

initial begin
      dm_toggle = 0;
end

always @(dm_toggle) begin
   if (dm_toggle == 0)
      $display ("INFO: Data Mask is Disabled.\n");
   else if (dm_toggle == 1)
      $display ("INFO: Data Mask is Enabled.\n");
end

assign ddr_dqm     = ddr_dqm_temp;
assign inv_ddr_dqs = ~ddr_dqs;
// ====================================================================
// Instantiate the memory controller module
// ====================================================================

ddr3_sdram_mem_top_ddr3_ip_inst U1_ddr_sdram_mem_top (
// Local User Interface
    .clk_in           (clk_in),
    .rst_n            (rst_n),
//`ifdef ENB_MEM_RST
    .mem_rst_n        (mem_rst_n),
//`endif 
    .init_start       (init_start),
    .cmd              (cmd),
    .addr             (addr),
    .cmd_burst_cnt    (ff_burst_count),
    .cmd_valid        (cmd_valid),
    .ofly_burst_len   (ofly_burst_len),
    .write_data       (write_data),
    .datain_rdy       (data_rdy),
    .data_mask        (dmsel),

    .cmd_rdy          (cmd_rdy),
    .init_done        (init_done),
    .rt_err           (),
    .wl_err           (),
    .read_data        (read_data),
    .read_data_valid  (read_data_valid),
    .sclk_out         (clk),
    .clocking_good    (clocking_good),

    .em_ddr_clk       (ddr_clk),
    .em_ddr_cke       (ddr_cke),
    .em_ddr_addr      (ddr_ad),
    .em_ddr_ba        (ddr_ba),
    .em_ddr_data      (ddr_dq),
    .em_ddr_dm        (ddr_dqm_temp),
    .em_ddr_dqs       (ddr_dqs),
    .em_ddr_reset_n   (ddr_resetn),
    .em_ddr_cs_n      (ddr_cs_n),
    .em_ddr_cas_n     (ddr_cas_n),
    .em_ddr_ras_n     (ddr_ras_n),
    .em_ddr_we_n      (ddr_we_n),
    .em_ddr_odt       (ddr_odt)
);


  `define ddr3_ip_inst_DIMM_CS_WIDTH 1
//--------------- DIMM 0 --------------------------------------

   ddr3_dimm_16_ddr3_ip_inst U0_ddr3_dimm (
       .rst_n              (ddr_resetn),
       .ddr_dq             (ddr_dq),
       .ddr_dqs            (ddr_dqs),
       .ddr_dqs_n          (inv_ddr_dqs),
       .ddr_dm_tdqs        (ddr_dqm),
       .ddr_ad             (ddr_ad),
       .ddr_ba             (ddr_ba),
       .ddr_ras_n          (ddr_ras_n),
       .ddr_cas_n          (ddr_cas_n),
       .ddr_we_n           (ddr_we_n),
       .ddr_cs_n           (ddr_cs_n[`ddr3_ip_inst_DIMM_CS_WIDTH-1:0]),
       .ddr_clk            (ddr_clk[`ddr3_ip_inst_DIMM_CS_WIDTH-1:0]),
       .ddr_clk_n          (~ddr_clk[`ddr3_ip_inst_DIMM_CS_WIDTH-1:0]),
       .ddr_cke            (ddr_cke[`ddr3_ip_inst_DIMM_CS_WIDTH-1:0]),
       .ddr_odt            (ddr_odt[`ddr3_ip_inst_DIMM_CS_WIDTH-1:0])
   );




// ====================================================================
// This file has all the tasks used in the tests to generate stimulus on
// the FPGA interface for the DDR memory controller
// ====================================================================

// ====================================================================
// Instantiate the protocol monitor
// ====================================================================
reg endoftest;

initial begin
    endoftest  = 0;
end

wire [1:0]  burst_len;
wire [31:0] mem_write_cnt;
wire [31:0] mem_read_cnt;
wire [3:0]  cas_latency;
wire [3:0]  cas_write_latency;

monitor_ddr3_ip_inst U1_monitor (
    .clk                       (clk),
    .mem_clk                   (ddr_clk[0]),
    .rst_n                     (rst_n),
    .endoftest                 (endoftest),
    .cmd                       (cmd),
    .cmd_valid                 (cmd_valid),
    .dmsel                     (dmsel),
    .addr                      (addr),
    .datain                    (write_data),
    .burst_cnt                 (ff_burst_count),
    .init_start                (init_start),
    .init_done                 (init_done),
    .ar_burst_en               (3'b000),
    .db_size                   (db_size),

    .ddr_cke                   (ddr_cke[0]),
    .ddr_we_n                  (ddr_we_n),
    .ddr_cs_n                  (ddr_cs_n[0:0]),
    .ddr_ad                    (ddr_ad),
    .ddr_ba                    (ddr_ba),
    .ddr_dqm                   (ddr_dqm),
    .ddr_dq                    (ddr_dq),
    .ddr_ras_n                 (ddr_ras_n),
    .ddr_cas_n                 (ddr_cas_n),
    .ddr_dqs                   (ddr_dqs),
    .user_clk                  (clk),
    .dataout                   (read_data),
    .cmd_rdy                   (cmd_rdy),
    .dataout_valid             (read_data_valid),
    .datain_valid              (data_rdy),
    .mem_write_cnt             (mem_write_cnt),
    .mem_read_cnt              (mem_read_cnt),
    .burst_len                 (burst_len),
    .cas_latency_true          (cas_latency),
    .cas_write_latency_true    (cas_write_latency),
    .self_ref_done             (self_ref_done)
);

odt_watchdog_ddr3_ip_inst U1_odt_watchdog (
    .mem_clk                   (ddr_clk[0]),
    .rst_n                     (rst_n),
    .ddr_cke                   (ddr_cke[0]),
    .ddr_cs_n                  (ddr_cs_n[0:0]),
    .ddr_ras_n                 (ddr_ras_n),
    .ddr_cas_n                 (ddr_cas_n),
    .ddr_we_n                  (ddr_we_n),
    .ddr_ad                    (ddr_ad),
    .ddr_ba                    (ddr_ba),
    .ddr_dqm                   (ddr_dqm),
    .ddr_dq                    (ddr_dq),
    .ddr_dqs                   (ddr_dqs),
    .ddr_odt                   (ddr_odt),
    .burst_len                 (burst_len),
    .cas_latency               (cas_latency),
    .cas_write_latency         (cas_write_latency),
    .self_ref_done             (self_ref_done)
);


// ====================================================================
// Initialize the static parameters
// ====================================================================

initial begin
   repeat (500000) @(posedge clk);
   $display ("============Testbench INFO: SIMULATION TIMEOUT=============");
   $stop;
end

initial begin
   db_size  = 4'b0001;
end

// set an flag to check if the monitor checking has passed.
reg error_flg;
reg odt_error_flg;

initial begin
    error_flg = 0;
    odt_error_flg = 0;
end
`include "cmd_gen.v"
`include "testcase.v"

endmodule
