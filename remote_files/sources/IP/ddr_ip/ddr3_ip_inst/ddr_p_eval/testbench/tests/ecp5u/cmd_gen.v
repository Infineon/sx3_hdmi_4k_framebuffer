// ===========================================================================
// Verilog module generated by IPexpress
// Filename: cmd_gen.v  
// Copyright 2009 (c) Lattice Semiconductor Corporation. All rights reserved.
// ===========================================================================

///////////////////////////////////////////////////////////////////////
// Supported commands
// read          (cmd_valid_lat, burst_count, row_addr, bank_addr, col_addr, otf)
// write         (cmd_valid_lat, burst_count, row_addr, bank_addr, col_addr, otf)
// reada         (cmd_valid_lat, burst_count, row_addr, bank_addr, col_addr, otf)
// writea        (cmd_valid_lat, burst_count, row_addr, bank_addr, col_addr, otf)
// self_ref      (cmd_valid_lat)
// load_mr       (cmd_valid_lat, bl, bt, cl, op)
// load_emr      (cmd_valid_lat, dll_disable, drive_strength)
// pdown         (cmd_valid_lat)
// init          ()
// burst_term    ()
//////////////////////////////////////////////////////////////////////

//---------------- Task reset ------------------------------------
task reset;
begin
  // Assert reset
  $display ("\nINFO: Ignore initial wait period warnings during functional simulation\n");
  rst_n              = 0;
  #(100*c) mem_rst_n = 0;
  
  // De-assert reset after 200 clock cycles
  #(100*c) rst_n     = 1;
  #(20*c)  mem_rst_n  = 1;
  
end
endtask

//---------------- Task init ------------------------------------
// This task provides a initialization request
task init;
begin
  $display ("\nINFO : Write Leveling procedure Entry. Ignore warnings until Write Leveling procedure Exit\n");
  // Assert init_start
   @(posedge clk);
   init_start   = 1;
   wait (init_done) @ (posedge clk);
   init_start   = 0;
  $display ("\nINFO : Write Leveling procedure Exit.\n");
end
endtask

//---------------- Task pdown -------------------------------------
// This task issues the powerdown command.
task pdown; 
input  cmd_valid_lat;   //0:de-assert comand valid, 
                        //1:keep cmd_valid asserted
begin

   //wait (cmd_rdy);
   @(posedge clk);
   #1;
   cmd         = 4'b0101;
   cmd_valid   = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
   end

/*
   // Stretch the command if the cmd_rdy was sampled asserted.
   // This will prevent the cmd_valid being de-asserted too soon.
   @(negedge cmd_rdy);
   @(posedge clk);
   #1;
   cmd_valid   = 1'b1;
   @(posedge clk);
   #1;
   @(negedge cmd_rdy);

   if (!cmd_valid_lat) begin
       @(negedge clk);
       cmd_valid = 1'b0;
   end
*/
end
endtask

task pdown_ext; 
input  cmd_valid_lat;   //0:de-assert comand valid, 
                        //1:keep cmd_valid asserted
begin

   @(posedge clk);
   #1;
   cmd         = 4'b1011;
   cmd_valid   = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
   end

/*
   // Stretch the command if the cmd_rdy was sampled asserted.
   // This will prevent the cmd_valid being de-asserted too soon.
   @(negedge cmd_rdy);
   @(posedge clk);
   #1;
   cmd_valid   = 1'b1;
   @(posedge clk);
   #1;
   @(negedge cmd_rdy);

   if (!cmd_valid_lat) begin
       @(negedge clk);
       cmd_valid = 1'b0;
   end
*/
end
endtask
//---------------- Task load_mr --------------------------------------

task load_mr0;

input        cmd_valid_lat;   //0:de-assert comand valid,
                              //1:keep cmd_valid asserted
input[3:0]   bl;
input        bt;
input[3:0]   cl;
input[3:0]   wr_rec;

reg  [1:0]   bl_bits;
reg  [3:0]   cl_bits;
reg  [2:0]   wr_bits;
begin
   @(posedge clk);
   #1;
   cmd         = 4'b0110;
   //check_bl_cl_wr (bl, cl, wr_rec, bl_bits, cl_bits, wr_bits);
   check_bl_cl_wr (bl, cl, `ddr3_ip_inst_TWR*`ddr3_ip_inst_X_FAC, bl_bits, cl_bits, wr_bits);
   addr[1:0]   = bl_bits;
   addr[2]     = cl_bits[0];
   addr[3]     = bt;
   addr[6:4]   = cl_bits[3:1];
   addr[7]     = 0;  //test mode set to 0
   addr[8]     = 0;  //dll reset set to No
   addr[11:9]  = wr_bits;
   addr[12]    = 0;  //Slow exit for Precharge_ddr3_ip_inst Powerdown(DLL off)
   addr[18:13] = 2'b00; //mode register 0;
   cmd_valid   = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
   end

/*
   // Stretch the command if the cmd_rdy was sampled asserted.
   // This will prevent the cmd_valid being de-asserted too soon.
   @(negedge cmd_rdy);
   @(posedge clk);
   #1;
   cmd_valid   = 1'b1;
   @(posedge clk);
   #1;
   @(negedge cmd_rdy);

   if (!cmd_valid_lat) begin
       @(negedge clk);
       cmd_valid = 1'b0;
   end
*/
end
endtask
//-------------- load_mr1 ---------------//
task load_mr1;
input        cmd_valid_lat;   //0:de-assert comand valid,
                              //1:keep cmd_valid asserted
input[1:0]   al;
input        write_lev;
input        tdqs;
input        qoff;

reg[1:0]     al_bits;
begin
   @(posedge clk);
   #1;
   cmd           = 4'b0110;
   addr[2:0]     = 3'b110;
   check_al (al, al_bits);
   addr[4:3]     = al_bits;

   addr[6:5]     = 2'b00;
   addr[7]       = write_lev;
   addr[10:8]    = 3'b000;
   addr[11]      = tdqs;
   addr[12]      = qoff;  
   addr[15:13]   = 3'b000; 
   addr[18:16]   = 3'b001;
   cmd_valid    = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
   end

end
endtask

//-------------- load_mr2 ---------------//
task load_mr2;
input        cmd_valid_lat;   //0:de-assert comand valid,
                              //1:keep cmd_valid asserted
input[3:0]   cwl;

reg[2:0]     cwl_bits;
begin
   @(posedge clk);
   #1;
   cmd           = 4'b0110;
   addr[2:0]     = 3'b0;  // Full array Self refresh
   check_cwl (cwl, cwl_bits); 
   addr[5:3]     = cwl_bits;
   addr[6]       = 1'b0;  // Manual Self refresh
   addr[7]       = 1'b0;  // normal operating temperature range
   addr[10:9]    = 2'b00; // dynamic odt off
   addr[15:11]   = 5'b00000; 
   addr[18:16]   = 3'b010;
   cmd_valid    = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
   end

end
endtask

//-------------- load_mr3 ---------------//
task load_mr3;
input        cmd_valid_lat;   //0:de-assert comand valid,
                              //1:keep cmd_valid asserted
input        mpr;

begin
   @(posedge clk);
   #1;
   cmd           = 4'b0110;
   addr[1:0]     = 2'b00; //Predefined pattern
   addr[2]       = mpr;
   addr[15:3]    = 13'b0000000000000; 
   addr[18:16]   = 3'b011;
   cmd_valid    = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
   end

end
endtask

// ZQ calibration Long
task zq_lng;
input        cmd_valid_lat;   //0:de-assert comand valid,
                              //1:keep cmd_valid asserted
begin
   @(posedge clk);
   #1;
   cmd           = 4'b1100;
   addr[9:0]     = 10'b0000000000;
   addr[10]      = 1'b0; // zq long
   addr[18:11]   = 8'b00000000;
   cmd_valid     = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
   end

end
endtask

// ZQ calibration Short
task zq_shrt;
input        cmd_valid_lat;   //0:de-assert comand valid,
                              //1:keep cmd_valid asserted
begin
   @(posedge clk);
   #1;
   cmd           = 4'b1101;
   addr[9:0]     = 10'b0000000000;
   addr[10]      = 1'b0; //zq short
   addr[18:11]   = 8'b00000000;
   cmd_valid     = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
   end

end
endtask


//---------------- Task self_ref --------------------------------------
`ifdef ddr3_ip_inst_EXT_AUTO_REF
task refresh;
input  cmd_valid_lat;   //0:de-assert comand valid,
                        //1:keep cmd_valid asserted
begin
   @(posedge clk);
   ext_auto_ref  = 1;
 //  @ (posedge clk);
 //  ext_auto_ref  = 0;
   while (!ext_auto_ref_ack) @ (posedge clk);
   ext_auto_ref  = 0;

end
endtask
`endif

//---------------- Task self_ref --------------------------------------


task self_ref;
input  cmd_valid_lat;   //0:de-assert comand valid,
begin
end
endtask

task self_ref_ext;
input  cmd_valid_lat;   //0:de-assert comand valid,
begin
end
endtask


/*
task self_ref;
input  cmd_valid_lat;   //0:de-assert comand valid,
                        //1:keep cmd_valid asserted
begin
   @(posedge clk);
   #1;
   cmd         = 4'b1000;
   cmd_valid   = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
   end

//
   // Stretch the command if the cmd_rdy was sampled asserted.
   // This will prevent the cmd_valid being de-asserted too soon.
   @(negedge cmd_rdy);
   @(posedge clk);
   #1;
   cmd_valid   = 1'b1;
   @(posedge clk);
   #1;
   //@(negedge cmd_rdy);
   
   if (!cmd_valid_lat) begin
       @(negedge clk);
       cmd_valid = 1'b0;
       end
//
end
endtask


task self_ref_ext;
input  cmd_valid_lat;   //0:de-assert comand valid,
                        //1:keep cmd_valid asserted
begin
   @(posedge clk);
   #1;
   cmd         = 4'b1001;
   cmd_valid   = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
   end

//
   // Stretch the command if the cmd_rdy was sampled asserted.
   // This will prevent the cmd_valid being de-asserted too soon.
   @(negedge cmd_rdy);
   @(posedge clk);
   #1;
   cmd_valid   = 1'b1;
   @(posedge clk);
   #1;
   //@(negedge cmd_rdy);
   
   if (!cmd_valid_lat) begin
       @(negedge clk);
       cmd_valid = 1'b0;
       end
//
end
endtask
*/

//---------------- Task read  -----------------------------------------
// read          (cmd_valid_lat, burst_count, row_addr, bank_addr, col_addr)
// This task issues the read command.
task read ;
input   cmd_valid_lat;   //0:de-assert comand valid,
		                   //1:keep cmd_valid asserted
input   burst_count;
input   row_addr;
input   bank_addr;
input   col_addr;
input   otf;

integer burst_count;
integer row_addr;
integer bank_addr;
integer col_addr;

begin
   @(posedge clk);
   #1;
   cmd         = 4'b0001;
   ff_burst_count   = burst_count;
   addr[`ddr3_ip_inst_COL_WIDTH-1:0]                           = col_addr;
`ifdef ddr3_ip_inst_CS_WIDTH_1
   addr[`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_COL_WIDTH]           = bank_addr;
`else
   addr[`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_COL_WIDTH]           = {cs_addr,bank_addr[2:0]};
`endif
   addr[`ddr3_ip_inst_ROW_WIDTH+`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH]     = row_addr;
   ofly_burst_len = otf;

   `ifndef ddr3_ip_inst_NO_INFO
   $display ("%t TB INFO: Read from Bank No.%5d, Row Addr :%5d, Col Addr: %5d", $time, bank_addr, row_addr, col_addr); 
   `endif

`ifdef ddr3_ip_inst_CMD_VALID_TYPE1
//1st cmd_rdy: skip and assert cmd_valid
   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b1;
   end

//2nd cmd_rdy: Deassert cmd_valid
//             If opted, deassert all user side signals
   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
      `ifdef ddr3_ip_inst_CLOSE_USR_SIG
        ff_burst_count   = 0;
        addr[`ddr3_ip_inst_COL_WIDTH-1:0]                      = 0;
        addr[`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_COL_WIDTH]      = 0;
        addr[`ddr3_ip_inst_ROW_WIDTH+`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH] = 0;
        ofly_burst_len = 1;
      `endif

   end

//3rd cmd_rdy: skip
   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
   end

`else

   cmd_valid   = 1'b1;
   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
       cmd       = 'd0;   
      `ifdef ddr3_ip_inst_CLOSE_USR_SIG
        ff_burst_count   = 0;
        addr[`ddr3_ip_inst_COL_WIDTH-1:0]                      = 0;
        addr[`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_COL_WIDTH]      = 0;
        addr[`ddr3_ip_inst_ROW_WIDTH+`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH] = 0;
        ofly_burst_len = 1;
      `endif

   end

`endif

/*
   // Stretch the command if the cmd_rdy was sampled asserted.
   // This will prevent the cmd_valid being de-asserted too soon.
   @(negedge cmd_rdy);
   @(posedge clk);
   #1;
   cmd_valid   = 1'b1;
   @(posedge clk);
   #1;
   @(negedge cmd_rdy);
   
   if (!cmd_valid_lat) begin
       @(negedge clk);
       cmd_valid = 1'b0;
       end
*/
end
endtask
//---------------- Task reada  -----------------------------------------
task reada;
input   cmd_valid_lat;   //0:de-assert comand valid,
                         //1:keep cmd_valid asserted
input   burst_count;
input   row_addr;
input [2:0] bank_addr;
input   col_addr;
input   otf;

integer burst_count;
integer row_addr;
integer bank_addr;
integer col_addr;

begin
   @(posedge clk);
   #1;
   cmd         = 4'b0011;
   ff_burst_count   = burst_count;
   addr[`ddr3_ip_inst_COL_WIDTH-1:0]                           = col_addr;
`ifdef ddr3_ip_inst_CS_WIDTH_1
   addr[`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_COL_WIDTH]           = bank_addr;
`else
   addr[`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_COL_WIDTH]           = {cs_addr,bank_addr[2:0]};
`endif
   addr[`ddr3_ip_inst_ROW_WIDTH+`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH]     = row_addr;
   ofly_burst_len = otf;
   cmd_valid   = 1'b1;
   `ifndef ddr3_ip_inst_NO_INFO
   $display ("%t TB INFO: Reada from Bank No.%5d, Row Addr :%5d, Col Addr: %5d", $time, bank_addr, row_addr, col_addr); 
   `endif 


   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
   end


/*
   // Stretch the command if the cmd_rdy was sampled asserted.
   // This will prevent the cmd_valid being de-asserted too soon.
   @(negedge cmd_rdy);
   @(posedge clk);
   #1;
   cmd_valid   = 1'b1;
   @(posedge clk);
   #1;
   @(negedge cmd_rdy);
   
   if (!cmd_valid_lat) begin
       @(negedge clk);
       cmd_valid = 1'b0;
       end
*/
end
endtask
//---------------- Task write  ----------------------------------------
task write;
input   cmd_valid_lat;   //0:de-assert comand valid,
                         //1:keep cmd_valid asserted
input   burst_count;
input   row_addr;
input [2:0] bank_addr;
input   col_addr;
input   otf;

integer burst_count;
integer row_addr;
integer bank_addr;
integer col_addr;

begin
   @(posedge clk);
   #1;
   cmd         = 4'b0010;
   ff_burst_count   = burst_count;
   addr[`ddr3_ip_inst_COL_WIDTH-1:0]                           = col_addr;
`ifdef ddr3_ip_inst_CS_WIDTH_1
   addr[`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_COL_WIDTH]           = bank_addr;
`else
   addr[`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_COL_WIDTH]           = {cs_addr,bank_addr[2:0]};
`endif

   addr[`ddr3_ip_inst_ROW_WIDTH+`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH]     = row_addr;
   ofly_burst_len = otf;

   `ifndef ddr3_ip_inst_NO_INFO
   $display ("%t TB INFO: Write to Bank No.%5d, Row Addr :%5d, Col Addr: %5d", $time, bank_addr, row_addr, col_addr); 
   `endif
`ifdef ddr3_ip_inst_CMD_VALID_TYPE1
   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b1;
   end

   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
      `ifdef ddr3_ip_inst_CLOSE_USR_SIG
//        ff_burst_count   = 0;
        addr[`ddr3_ip_inst_COL_WIDTH-1:0]                      = 0;
        addr[`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_COL_WIDTH]      = 0;
        addr[`ddr3_ip_inst_ROW_WIDTH+`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH] = 0;
        ofly_burst_len = 0;
      `endif

   end


   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
   end
`else

   cmd_valid   = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
       cmd       = 'd0;   
      `ifdef ddr3_ip_inst_CLOSE_USR_SIG
//        ff_burst_count   = 0;
        addr[`ddr3_ip_inst_COL_WIDTH-1:0]                      = 0;
        addr[`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_COL_WIDTH]      = 0;
        addr[`ddr3_ip_inst_ROW_WIDTH+`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH] = 0;
        ofly_burst_len = 0;
      `endif

   end
`endif

/*
   // Stretch the command if the cmd_rdy was sampled asserted.
   // This will prevent the cmd_valid being de-asserted too soon.
   @(negedge cmd_rdy);
   @(posedge clk);
   #1;
   cmd_valid   = 1'b1;
   @(posedge clk);
   #1;
   @(negedge cmd_rdy);
   
   if (!cmd_valid_lat) begin
       @(negedge clk);
       cmd_valid = 1'b0;
       end
*/
end
endtask

//---------------- Task writea  ----------------------------------------
task writea;
input   cmd_valid_lat;  //0:de-assert comand valid,
                        //1:keep cmd_valid asserted
input   burst_count;
input   row_addr;
input [2:0]  bank_addr;
input   col_addr;
input   otf;

integer burst_count;
integer row_addr;
integer bank_addr;
integer col_addr;

begin
   @(posedge clk);
   #1;
   cmd = 4'b0100;
   ff_burst_count   = burst_count;
   addr[`ddr3_ip_inst_COL_WIDTH-1:0]                                       = col_addr;
`ifdef ddr3_ip_inst_CS_WIDTH_1
   addr[`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_COL_WIDTH]                       = bank_addr;
`else
   addr[`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_COL_WIDTH]                       = {cs_addr,bank_addr[2:0]};
`endif
   addr[`ddr3_ip_inst_ROW_WIDTH+`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH-1:`ddr3_ip_inst_BSIZE+`ddr3_ip_inst_COL_WIDTH]     = row_addr;
   ofly_burst_len = otf;
   cmd_valid   = 1'b1;
   `ifndef ddr3_ip_inst_NO_INFO
   $display ("%t TB INFO: Writea to Bank No.%5d, Row Addr :%5d, Col Addr: %5d", $time, bank_addr, row_addr, col_addr); 
   `endif

   if (!cmd_valid_lat) begin
       wait (cmd_rdy);
       @(posedge clk);
       #1;
       cmd_valid = 1'b0;
       //write_data = 64'h0123_4567_89ab_cdef;
   end


/*
   // Stretch the command if the cmd_rdy was sampled asserted.
   // This will prevent the cmd_valid being de-asserted too soon.
   @(negedge cmd_rdy);
   @(posedge clk);
   #1;
   cmd_valid   = 1'b1;
   @(posedge clk);
   #1;
   @(negedge cmd_rdy);
   
   if (!cmd_valid_lat) begin
       @(negedge clk);
       cmd_valid = 1'b0;
       end
*/
end
endtask

task check_al;
input [1:0] al_in;
output [1:0] al_out;
reg [1:0] al_out;

begin
      case (al_in)
         0 : al_out = 2'b00;  
         1 : al_out = 2'b01;  
         2 : al_out = 2'b10;  
      endcase
end

endtask

// check cas write latency
task check_cwl;
input [3:0] cwl_in;
output [2:0] cwl_out;
reg [2:0] cwl_out;
begin
      case (cwl_in)
         5 : cwl_out = 3'b000;
         6 : cwl_out = 3'b001;
         7 : cwl_out = 3'b010;
         8 : cwl_out = 3'b011;
         default : cwl_out = 3'b000;
      endcase
end

endtask


//---------------- Task check_bl_cl ---------------------------------
task check_bl_cl_wr;
input  [3:0] bl_in;
input  [3:0] cl_in;
input  [3:0] wr_in;

output [1:0] bl_out;
output [3:0] cl_out;
output [2:0] wr_out;

reg    [1:0] bl_out;
reg    [3:0] cl_out;
reg    [2:0] wr_out;
begin
   if((bl_in !== 4) && (bl_in !== 8) && (bl_in !== 0)) begin
      $display ("cmd_gen ERROR: at time %0t, Illegal Burst Length value %b\n",$time,bl_in); 
      $display ("cmd_gen ERROR: Allowed values: 4, 8, 0(on-the-fly) \n", 4, 8, 0);
      $display ("cmd_gen ERROR: Burst Length set to 8\n");
      bl_out = 2'b00; //bl set to 8
   end
   else begin
`ifdef ddr3_ip_inst_X4_GEAR   // In x4 mode only BL8 is supported
      case (bl_in)
         4 : bl_out = 2'b00;  // bl 8
         8 : bl_out = 2'b00;  // bl 8
         0 : bl_out = 2'b00;  // bl 8 
      endcase
`else
      case (bl_in)
         4 : bl_out = 2'b10;  // bc 4
         8 : bl_out = 2'b00;  // bl 8
         0 : bl_out = 2'b01;  // on-the-fly
      endcase
`endif
   end

   if((cl_in < 5) || (cl_in > 11)) begin
      $display ("cmd_gen ERROR: at time %0t, Illegal CAS Latency %b\n",$time,cl_in); 
      $display ("cmd_gen ERROR: Allowed values: 5,6,7,8,9,10,11(only for DDR3-1600) \n");
      $display ("cmd_gen ERROR: CAS Latency set to 6 \n");
   cl_out = 4'b0100; //cl set to 6
   end
   else begin
      case (cl_in)
         5  : cl_out = 4'b0010;
         6  : cl_out = 4'b0100;
         7  : cl_out = 4'b0110;
         8  : cl_out = 4'b1000;
         9  : cl_out = 4'b1010;
         10 : cl_out = 4'b1100;
         11 : cl_out = 4'b1110;
      endcase
   end

   if((wr_in < 5) || (wr_in > 12) || (wr_in == 9) || (wr_in == 11)) begin
      $display ("cmd_gen ERROR: at time %0t, Illegal Write recovery cycles %b\n",$time,wr_in); 
      $display ("cmd_gen ERROR: Allowed values: 5,6,7,8,9,10,11(only for DDR3-1600) \n");
      $display ("cmd_gen ERROR: CAS Latency set to 6 \n");
   wr_out = 3'b010; //wr set to 6
   end
   else begin
      case (wr_in)
         5  : wr_out = 3'b001;
         6  : wr_out = 3'b010;
         7  : wr_out = 3'b011;
         8  : wr_out = 3'b100;
         10 : wr_out = 3'b101;
         12 : wr_out = 3'b110;
      endcase
   end
end
endtask
//---------------- Task generate_data --------------------------------
task generate_data;
output [`ddr3_ip_inst_DSIZE+(`ddr3_ip_inst_DSIZE/8)-1:0] data_out ;
reg    [`ddr3_ip_inst_DSIZE+(`ddr3_ip_inst_DSIZE/8)-1:0] data_out ;
reg    [`ddr3_ip_inst_DSIZE-1:0]            int_data_out ;
reg    [7:0]                   data8   [35:0];
reg    [`ddr3_ip_inst_USER_DM-1:0]          dm_bits;
reg    [71:0]          int_dm_bits;
integer                        i,j;
integer                        seed;
integer                        data8_cnt;

begin

`ifdef ddr3_ip_inst_DATA_SIZE_72
    data8_cnt  = 36;
`endif

`ifdef ddr3_ip_inst_DATA_SIZE_64
    data8_cnt  = 32;
`endif

`ifdef ddr3_ip_inst_DATA_SIZE_56
    data8_cnt  = 28;
`endif

`ifdef ddr3_ip_inst_DATA_SIZE_48
    data8_cnt  = 24;
`endif

`ifdef ddr3_ip_inst_DATA_SIZE_40
    data8_cnt  = 20;
`endif

`ifdef ddr3_ip_inst_DATA_SIZE_32
    data8_cnt  = 16;
`endif

`ifdef ddr3_ip_inst_DATA_SIZE_24
    data8_cnt  = 12;
`endif

`ifdef ddr3_ip_inst_DATA_SIZE_16
    data8_cnt  = 8;
`endif

`ifdef ddr3_ip_inst_DATA_SIZE_8
    data8_cnt  = 4;
`endif

     dm_bits = 'd0;

     //for (i=0; i<18; i=i+1) begin
     for (i=0; i<36; i=i+1) begin
	    seed = seed+1;
	    data8[i] = $random(seed);
     end
     int_dm_bits = {data8[8], data8[7], data8[6], data8[5],
                    data8[4], data8[3], data8[2], data8[1], 
                    data8[0]};

     `ifdef ddr3_ip_inst_DATA_SIZE_72
          int_data_out = {data8[35], data8[34], data8[33], data8[32],
                          data8[31], data8[30], data8[29], data8[28], 
                          data8[27], data8[26], data8[25], data8[24],
                          data8[23], data8[22], data8[21], data8[20], 
                          data8[19], data8[18], data8[17], data8[16], 
                          data8[15], data8[14], data8[13], data8[12],
                          data8[11], data8[10], data8[9], data8[8],
                          data8[7], data8[6], data8[5], data8[4],
                          data8[3], data8[2], data8[1], data8[0]};
          dm_bits = int_dm_bits[35:0];
     `endif

     `ifdef ddr3_ip_inst_DATA_SIZE_64
          int_data_out = {data8[31], data8[30], data8[29], data8[28], 
                          data8[27], data8[26], data8[25], data8[24],
                          data8[23], data8[22], data8[21], data8[20], 
                          data8[19], data8[18], data8[17], data8[16], 
                          data8[15], data8[14], data8[13], data8[12],
                          data8[11], data8[10], data8[9], data8[8],
                          data8[7], data8[6], data8[5], data8[4],
                          data8[3], data8[2], data8[1], data8[0]};
          dm_bits = int_dm_bits[31:0];
     `endif

     `ifdef ddr3_ip_inst_DATA_SIZE_56
          int_data_out = {data8[27], data8[26], data8[25], data8[24],
                          data8[23], data8[22], data8[21], data8[20], 
                          data8[19], data8[18], data8[17], data8[16], 
                          data8[15], data8[14], data8[13], data8[12],
                          data8[11], data8[10], data8[9], data8[8],
                          data8[7], data8[6], data8[5], data8[4],
                          data8[3], data8[2], data8[1], data8[0]};
          dm_bits = int_dm_bits[27:0];
     `endif


     `ifdef ddr3_ip_inst_DATA_SIZE_48
          int_data_out = {data8[23], data8[22], data8[21], data8[20], 
                          data8[19], data8[18], data8[17], data8[16], 
                          data8[15], data8[14], data8[13], data8[12],
                          data8[11], data8[10], data8[9], data8[8],
                          data8[7], data8[6], data8[5], data8[4],
                          data8[3], data8[2], data8[1], data8[0]};
          dm_bits = int_dm_bits[23:0];
     `endif


     `ifdef ddr3_ip_inst_DATA_SIZE_40
 
          int_data_out = {data8[19], data8[18], data8[17], data8[16], 
                          data8[15], data8[14], data8[13], data8[12],
                          data8[11], data8[10], data8[9], data8[8],
                          data8[7], data8[6], data8[5], data8[4],
                          data8[3], data8[2], data8[1], data8[0]};
          dm_bits = int_dm_bits[19:0];
     `endif

     `ifdef ddr3_ip_inst_DATA_SIZE_32
          int_data_out = {data8[15], data8[14], data8[13], data8[12],
                          data8[11], data8[10], data8[9], data8[8],
                          data8[7], data8[6], data8[5], data8[4],
                          data8[3], data8[2], data8[1], data8[0]};
          dm_bits = int_dm_bits[15:0];
     `endif

     `ifdef ddr3_ip_inst_DATA_SIZE_24
          int_data_out = {data8[11], data8[10], data8[9], data8[8],
                          data8[7], data8[6], data8[5], data8[4],
                          data8[3], data8[2], data8[1], data8[0]};
          dm_bits = int_dm_bits[11:0];
     `endif

     `ifdef ddr3_ip_inst_DATA_SIZE_16
          int_data_out = {data8[7], data8[6], data8[5], data8[4],
                          data8[3], data8[2], data8[1], data8[0]};
          dm_bits = int_dm_bits[7:0];
     `endif

     `ifdef ddr3_ip_inst_DATA_SIZE_8
          int_data_out = {32'hffffffff,data8[3], data8[2], data8[1], data8[0]};
          dm_bits = int_dm_bits[3:0];
     `endif

      data_out = {dm_bits, int_data_out};
end
endtask

//------------ Sending data for write/writea tasks --------------------
reg datain_valid_d;
reg datain_valid_2d;
reg datain_valid_3d;

always@ (posedge clk) begin
    if(rst_n == 0) begin
      datain_valid_d  <= 1'b0;
    end 
    else begin 
       datain_valid_d  <= data_rdy;
       datain_valid_2d  <= datain_valid_d;
       if (`ddr3_ip_inst_WrRqDDelay == 2'b01) begin
           if(data_rdy) begin
              generate_data({data_mask,write_data});
           end 
           else if (datain_valid_d) begin
               write_data = 0;
               data_mask  = 0;
           end
       end 
       else if (`ddr3_ip_inst_WrRqDDelay == 2'b10) begin
           if(datain_valid_d) begin
              generate_data({data_mask,write_data});
           end 
           else if (datain_valid_2d) begin
               write_data = 0;
               data_mask  = 0;
           end
       end
    end
end

always @ (data_mask or dm_toggle) begin
    if (dm_toggle)
        dmsel = #1 data_mask;
    else
        dmsel = 16'b0;
end

